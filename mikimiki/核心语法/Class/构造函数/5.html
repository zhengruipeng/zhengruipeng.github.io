<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    class Polygon {
      constructor() {
        this.name = "Polygon";
      }
    }

    let Rectangle = function (){
      this.name = "Rectangle";
      console.log(this)

    }

    /*class Square extends Polygon {
        constructor() {
            super();
        }
    }*/
    let Square = function (){
      // super();
      // Square.prototype.call(this);
    };

    Square.prototype = new Polygon();
    Square.prototype.constructor = Square;

    // Make Square extend Rectangle (which is a base class) instead of Polygon
    // Object.setPrototypeOf(Square, Rectangle);
    // Square.prototype = Rectangle;
    Object.setPrototypeOf(Square,Rectangle)

    //次行代码用于判断prototype是否只读
    // console.log(Square.prototype)
    //Square -> Rectangle -> Function.prototype -> Object.prototype

    const newInstance = new Square();

    // newInstance is still an instance of Polygon, because we didn't
    // change the prototype of Square.prototype, so the prototype chain
    // of newInstance is still
    //   newInstance --> Square.prototype --> Polygon.prototype
    console.log(Square)
    console.log(newInstance)
    console.log(newInstance instanceof Polygon); // true
    console.log(newInstance instanceof Rectangle); // false

    // However, because super() calls Rectangle as constructor, the name property
    // of newInstance is initialized with the logic in Rectangle
    console.log(newInstance.name); // Rectangle

  })
</script>
</body>
</html>